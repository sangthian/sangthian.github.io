<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring基础(2)-IOC理论推导和本质</title>
    <url>/2020/04/05/Spring%E5%9F%BA%E7%A1%80-2-IOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC%E5%92%8C%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>使用maven新建一个项目</p>
<p>添加一个UserDao接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现这个UserDao接口：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取用户数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加一个UserService接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现这个UserService接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl(); </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser(); <span class="comment">// 调用Dao层方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类，模拟controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	UserService service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "获取用户数据"</span></span><br></pre></td></tr></table></figure>

<p>现在如果UserDao的实现类增加一个，比如叫<code>UserDaoMySqlImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMySqlImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取MySql用户数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着我们要去使用MySql的话 , 我们就需要去UserService实现类里面修改对应的实现 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoMySqlImpl();  <span class="comment">// 修改实例对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser(); <span class="comment">// 调用Dao层方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还有更多类似的需求，那么代码改动量将会很大，因此 这种设计的耦合性太高了，牵一发而动全身 ，不适合快速变化的业务系统。</p>
<h2 id="方法改进"><a href="#方法改进" class="headerlink" title="方法改进"></a>方法改进</h2><p>UserService的实现类不是直接去New一个新的实例，而是留出set接口，让调用者决定选择哪个具体的Dao实现，当然这其中有多态的思想在里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">// 利用set方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再使用测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	UserService service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    service.setUserDao(<span class="keyword">new</span> UserDaoMySqlImpl());</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "获取MySql用户数据"</span></span><br></pre></td></tr></table></figure>

<p>虽然只是一个简单的例子，但其中包含的设计思想确实比较高级的：</p>
<ul>
<li>以前所有东西都是由程序去进行控制创建</li>
<li>而现在使用了set注入，主动权交给了调用者</li>
<li>程序不用去管怎么创建，而是专注于业务逻辑的实现，耦合性大大降低 . 这也就是IOC的原型 。</li>
</ul>
<h2 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h2><p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/IOC%E7%90%86%E8%AE%BA%E8%83%8C%E6%99%AF.png" alt="IOC理论背景"></p>
<p><strong>控制反转（IOC）是一种设计思想，依赖注入（DI）是实现IOC的一种方式</strong>。在没有IOC的程序中，我们使用面向对象编程，对象的创建和对象之间的依赖完全硬编码在程序中，对象的创建由程序自己控制，控制反转后对象的创建转移给第三方，也就是“<strong>获得依赖对象的方式反转了</strong>”。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>IOC的另外的名字叫做依赖注入（Dependency Injection），所谓的依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，<strong>就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%B1%BB%E6%AF%94.png" alt="依赖注入类比"></p>
<p>类似上图一样：从外部usb读取文件，主机没必要知道通过啥设备，只要符合连接接口就可以了，外部设备主动权由我们自己控制，这样就解耦到最低。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(3)-第一个Spring Demo</title>
    <url>/2020/04/05/Spring%E5%9F%BA%E7%A1%80-3-%E7%AC%AC%E4%B8%80%E4%B8%AASpring-Demo/</url>
    <content><![CDATA[<h2 id="Spring-Demo"><a href="#Spring-Demo" class="headerlink" title="Spring Demo"></a>Spring Demo</h2><p>利用maven新建一个空的项目，然后逐步添加Spring相关代码，以最简单的Demo理解Spring的IOC原理。</p>
<p>添加maven依赖：<a id="more"></a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建<code>com.mx.pojo.Hello</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello,"</span> + name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写<code>resources.beans.xml</code>配置文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用Spring来创建对象，在Spring中这些对象都称之为Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Hello"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--类中的属性成员，可以赋初值，通过setter方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"jesse"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试类<code>test.MyTest</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取xml配置文件，获取Spring的上下文对象</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        <span class="comment">// 根据bean的id选取，获得对象实例</span></span><br><span class="line">        Hello hello = (Hello) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line">        hello.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "Hello,jesse"</span></span><br></pre></td></tr></table></figure>

<p><code>ClassPathXmlApplicationContext</code>和<code>ApplicationContext</code>存在N次继承关系，是利用多态的向上转型，从类名中可以探知，获取上下文对象的方式除了xml配置之外，还有其他的，比如注解、文件等。</p>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><ul>
<li><p>hello对象是谁创建的？</p>
<ul>
<li>hello对象是由Spring创建的，程序中没有new</li>
</ul>
</li>
<li><p>hello对象的属性是怎么设置的？   </p>
<ul>
<li>hello对象的属性是由Spring容器设置的</li>
</ul>
</li>
</ul>
<p>这个过程就叫做控制反转：</p>
<ul>
<li>控制：谁来控制对象的创建，在使用Spring之后，对象是由Spring来创建</li>
<li>反转：程序本身不创建对象，变成被动的接受对象</li>
<li>依赖注入：利用set方法进行注入</li>
</ul>
<p>因此对于初级的Spring程序，要实现不同的操作，只需要在xml配置文件中进行修改，IoC的也就成了：对象由Spring来创建、管理和装配！</p>
<h2 id="案例进阶"><a href="#案例进阶" class="headerlink" title="案例进阶"></a>案例进阶</h2><p>利用ref，引用Spring中创建好的bean对象：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySqlImpl"</span> <span class="attr">class</span>=<span class="string">"com.mx.dao.UserDaoMySqlImpl"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"UserServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.mx.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"mySqlImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(4)-IOC创建对象的方式</title>
    <url>/2020/04/05/Spring%E5%9F%BA%E7%A1%80-4-IOC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="通过无参构造函数"><a href="#通过无参构造函数" class="headerlink" title="通过无参构造函数"></a>通过无参构造函数</h2><p>Spring容器中创建对象，虽然没有显式的new，但说到底还是需要利用构造函数。如果xml配置中没有指定，那么默认通过无参构造函数进行创建，证明的示例如下：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Hello()&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello,"</span> + name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用之前的测试类main函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取xml配置文件，获取Spring的上下文对象</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        <span class="comment">// 在执行getBean的时候，hello对象已经创建好了，通过无参构造</span></span><br><span class="line">        Hello hello = (Hello) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line">        hello.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "这是无参构造方法"</span></span><br><span class="line"><span class="comment">// print "Hello,jesse"</span></span><br></pre></td></tr></table></figure>

<h2 id="通过有参构造函数"><a href="#通过有参构造函数" class="headerlink" title="通过有参构造函数"></a>通过有参构造函数</h2><p>修改Hello类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Hello(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">"这是有参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello,"</span> + name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beans.xml有三种编写方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种根据index参数下标设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Hello"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- index指构造方法,下标从0开始 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"jesse"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二种根据参数名字设置，推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Hello"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name指参数名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"jesse"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第三种根据参数类型设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"jesse"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring配置简单说明"><a href="#Spring配置简单说明" class="headerlink" title="Spring配置简单说明"></a>Spring配置简单说明</h2><ul>
<li>alias</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--别名，如果添加了别名，也可以使用它来获取这个对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">alias</span>=<span class="string">"hello2"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bean</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--id：bean的唯一标识符--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--class：bean对象的全限定名：包名+类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：也是别名，可以取多个，用空格、逗号或者分好分隔均可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">name</span>=<span class="string">"hello2 h2,h3;h4"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Hello"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>import</li>
</ul>
<p>一般用于团队开发使用，可将多个配置文件导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"&#123;path&#125;/beans.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(5)-依赖注入</title>
    <url>/2020/04/11/Spring%E5%9F%BA%E7%A1%80-5-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="关于依赖注入"><a href="#关于依赖注入" class="headerlink" title="关于依赖注入"></a>关于依赖注入</h2><p>依赖注入（Dependency Injection，DI），是指程序运行过程中，如果需要调用另一个java对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。</p>
<ul>
<li>依赖：Bean对象的创建依赖于容器 . Bean对象的依赖资源。</li>
<li>注入：Bean对象所依赖的资源 , 由容器来设置和装配。<a id="more"></a></li>
</ul>
<p>主要分为三种方式：构造器注入，set注入（重点）和扩展方式注入，其中构造器注入的方式在前文中有提及，重点关注set注入。</p>
<h2 id="Set方式注入"><a href="#Set方式注入" class="headerlink" title="Set方式注入"></a>Set方式注入</h2><p>根据简单示例代码来学习了解这一部分内容</p>
<h3 id="简单set注入"><a href="#简单set注入" class="headerlink" title="简单set注入"></a>简单set注入</h3><p>首先新建<code>com.mx.pojo.Student</code>类，包含各种类型的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后新建配置文件<code>beans.xml</code>，顺便说下，只要在pom中配置了spring-mvc的依赖，那么就能在idea中看到新建spring xml配置的选项，可以直接生成模板：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加spring-mvc依赖之后可以看到该模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Student"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一种，普通value赋值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"jesse"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>a</span><br></pre></td></tr></table></figure>

<p>最后新建测试类<code>test.java.MyTest</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mx.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =  <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">"student"</span>);</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "jesse"</span></span><br></pre></td></tr></table></figure>

<p>完成以上三步，就能实现最简单的属性set注入</p>
<h3 id="其他类型的注入"><a href="#其他类型的注入" class="headerlink" title="其他类型的注入"></a>其他类型的注入</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Address"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Student"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一种，普通value赋值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"jesse"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第二种，bean引用注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第三种，数组注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"books"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第四种，list注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第五种，map注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"vip"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第六种，配置类注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"year"</span>&gt;</span>2020<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"month"</span>&gt;</span>04<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后这个bean的各个属性初值就被注入，然后只需要使用就可以了。</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>Spring IOC容器创建一个Bean实例时，可以为Bean指定实例的作用域，作用域包括singleton（单例模式）、prototype（原型模式）、request（HTTP请求）、session（会话）、global-session（全局会话）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="bean的作用域"></p>
<ul>
<li>单例模式（Spring默认机制）</li>
</ul>
<p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.User"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原型模式，每次从容器中get的时候，都会产生一个新的对象</li>
</ul>
<p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">calss</span>=<span class="string">"com.mx.pojo.User"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其余的request，session，application作用域</li>
</ul>
<p>仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架）</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(6)-Bean的自动装配</title>
    <url>/2020/04/11/Spring%E5%9F%BA%E7%A1%80-6-Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h2 id="XML自动装配"><a href="#XML自动装配" class="headerlink" title="XML自动装配"></a>XML自动装配</h2><p>之前在<code>beans.xml</code>文件中手动为对象赋初值的操作，就是手动装配，显然这是比较麻烦的，书写量比较大，那么我们就需要一种自动的机制来做这件事。</p>
<p>自动装配是Spring满足bean依赖的一种方式。Spring会在上下文中自动寻找，并自动给bean装配属性。<a id="more"></a></p>
<p>Spring中有三种装配的方式：</p>
<ul>
<li>在xml中显式的配置</li>
<li>在java中显式的配置</li>
<li>隐式的自动装配</li>
</ul>
<p>通过简单例子XML自动装配，来了解这一原理</p>
<p>新建传统三件套，<code>pojo</code>，<code>beans.xml</code>和测试类，首先是pojo类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"miao"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"wang"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，我们想对People类自动注入，它有两个引用对象dog和cat，正常写法是使用ref，但我们也可以使用autowired来自动装配：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Cat"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Dog"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--byName，会自动在容器上下文中查找，和自己对象set方法后面值对应的bean的id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.People"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"jesse"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>autowire=“byName”这个配置项允许Spring容器根据name来自动对bean进行装配（赋值），这里列举autowired常用的方式：</p>
<ul>
<li><p>byName</p>
<p>会自动在容器上下文中查找，和自己对象set方法对应的name相同的bean，使用id来查找，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致</p>
</li>
<li><p>byType</p>
<p>会自动在容器上下文中查找，和自己对象属性类型相同的bean，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</p>
</li>
</ul>
<h2 id="使用注解实现自动装配"><a href="#使用注解实现自动装配" class="headerlink" title="使用注解实现自动装配"></a>使用注解实现自动装配</h2><p>使用注解的自动装配比XML要方便，是官方推荐的方式，注解支持的最低jdk版本是1.5.</p>
<p>要使用注解，需要如下支持：</p>
<ul>
<li>导入约束：context约束</li>
<li>配置注解的支持：<code>&lt;context:annotation-config/&gt;</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Cat"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.Dog"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.mx.pojo.People"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后直接在属性上使用<code>@Autowired</code>，就实现了属性的自动注入。也可以在set方法上使用，一般而言，使用<code>@Autowired</code>之后，我们就可以不写set方法了，前提是这个这个自动装配的属性在IoC（Spring）容器中存在，且按照先类型再名字的方式匹配。</p>
<p><code>@Autowired</code>存在一个属性设置<code>required</code>，来看一下它的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">private</span> Cat cat；</span><br></pre></td></tr></table></figure>

<p>如果属性的name无法匹配，且类型无法唯一对应，比如出现多个不同id的Dog类型的bean，还想通过<code>@Autowired</code>自动装配的话，就要借助于另一个注解：<code>@Qualifier</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = <span class="string">"dog2"</span>) <span class="comment">// 指定一个id值进行装配，但是也要符合相同类型才行</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>总结：如果自动装配的环境比较复杂，无法使用一个注解完成装配，可以使用<code>@Qualifier</code>去配合<code>@Autowired</code>的使用，制定一个唯一的bean对象进行注入。</p>
<p>java还有一个原生注解<code>@Resource</code>注解，类似于上述二者的结合体，首先通过名字匹配，然后会通过类型匹配，这个功能强大，但是用的相对较少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"cat2"</span>)</span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>总结下<code>@Autowired</code>和<code>@Resource</code>的关系和区别：</p>
<ul>
<li><p>都可以用来自动装配，可以放在属性字段上</p>
</li>
<li><p><code>@Autowired</code>，属于Spring规范，默认通过byType方式实现，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
</li>
<li><p><code>@Resource</code>，属于J2EE规范，默认通过byName方式实现，如果找不到name，则通过byType实现，如果都找不到会提示报错。同时，如果name属性一旦指定，就只会按照名称进行装配。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(7)-使用注解开发</title>
    <url>/2020/04/14/Spring%E5%9F%BA%E7%A1%80-7-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="Bean的注入"><a href="#Bean的注入" class="headerlink" title="Bean的注入"></a>Bean的注入</h2><p>随着Spring技术的发展，目前已经越来越多使用注解开发，而Spring Boot更是可以做到全注解。</p>
<p>在Spring4之后，要使用注解进行开发，必须导入aop的包，且在配置文件中需要context的约束。</p>
<p>我们之前都是使用xml配置文件来定义bean，现在可以使用注解了。首先是配置扫描哪些包下面的注解，配置如下：<a id="more"></a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.mx.pojo"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在指定的包下编写类，增加一个<code>@Component</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id="user" class="当前注解的类"/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"jesse"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Component</code>：关于组件的注解，放在类上，说明这个类被Spring管理了，变成了bean。</p>
<h2 id="属性的注入"><a href="#属性的注入" class="headerlink" title="属性的注入"></a>属性的注入</h2><p>我们使用<code>@Value</code>注解来对属性进行注入。</p>
<p>方式1：不提供set方法，直接在属性定义上添加注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id="user" class="当前注解的类"/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"jesse"</span>)</span><br><span class="line">    <span class="comment">// 相当于配置文件中 &lt;property name="name" value="jesse"/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：如果提供了set方法，那么可以在set方法上添加注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"jesse"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="衍生的注解"><a href="#衍生的注解" class="headerlink" title="衍生的注解"></a>衍生的注解</h2><p><code>@Component</code>有几个衍生的注解，在微博开发中会按照mvc三层架构进行分级，于是产生了下列的衍生注解：</p>
<ul>
<li><code>@Controller</code>：web层</li>
<li><code>@Service</code>：service层</li>
<li><code>@Repository</code>：dao层</li>
</ul>
<p>这几个注解在功能上本质是一样的，都是将类交给Spring来管理，注册成为bean。分开只是为了分层管理。</p>
<h2 id="自动装配的注解"><a href="#自动装配的注解" class="headerlink" title="自动装配的注解"></a>自动装配的注解</h2><p>也就是前面讲到的<code>@Autowired</code>，补充说下<code>@Autowired</code>的三种应用场景，分别是字段（变量）注入，构造器注入和set注入，举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量（filed）注入：</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoginService loginService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器注入</span></span><br><span class="line"><span class="keyword">private</span> LoginService loginService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoginController</span> <span class="params">(LoginService loginService)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.loginService = loginService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set方法注入</span></span><br><span class="line"><span class="keyword">private</span> LoginService loginService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginService</span> <span class="params">(LoginService loginService)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.loginService = loginService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三者的关系和区别：</p>
<ul>
<li>变量注入：过于依赖注入容器了，当没有启动整个依赖容器时，这个类就不能运转，在反射时无法提供这个类需要的依赖。不推荐使用，在Idea中会提示“Field injection is not recommended”的警告</li>
<li>构造器注入：如果注入的属性是必选的属性，则通过构造器注入。某些强制规范的类，都采用此方式。</li>
<li>set注入：如果注入的属性是可选的属性，则通过setter方法注入。set注入的好处在于可有可无，即使没有注入这个依赖，那么也不会影响整个类的运行。</li>
</ul>
<h2 id="作用域注解"><a href="#作用域注解" class="headerlink" title="作用域注解"></a>作用域注解</h2><p>使用<code>@scope</code>注解：</p>
<ul>
<li>singleton：默认，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"jesse"</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Java类进行配置"><a href="#使用Java类进行配置" class="headerlink" title="使用Java类进行配置"></a>使用Java类进行配置</h2><p>现在完全不使用Spring的xml来进行配置，全部交给Java来做。利用Spring的子项目JavaConfig来做。</p>
<p>新建pojo类<code>com.mx.pojo.User</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说明这个类被Spring接管了，注册到了容器中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性注入值</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"jesse"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建配置类<code>com.mx.config.AppConfig</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个也会被Spring容器托管，注册到容器中</span></span><br><span class="line"><span class="comment">// 本质上是一个@Component，@Configuration代表这个是配置类，和beans.xml起的作用是一致的</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.mx.pojo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个Bean，相当于xml中的bean标签</span></span><br><span class="line">    <span class="comment">// 方法的名字，相当于bean标签中的id属性</span></span><br><span class="line">    <span class="comment">// 方法的返回值，相当于bean标签的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();  <span class="comment">// 返回注入的bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = context.getBean(<span class="string">"getUser"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "jesse"</span></span><br></pre></td></tr></table></figure>

<p>再补充下，导入其他配置的做法：再次编写一个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig2</span> </span>&#123;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入这个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(AppConfig2<span class="class">.<span class="keyword">class</span>)  //导入合并其他配置类，类似于配置文件中的<span class="title">inculde</span>标签</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处例子比较简单，更多的内容需要去官方文档查看。</p>
<p>全注解开发是Spring Boot的精髓之一，之后的学习需要更多了解这方面内容。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(8)-静态代理和动态代理</title>
    <url>/2020/04/18/Spring%E5%9F%BA%E7%A1%80-8-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为什么我们要接触学习代理模式，因为这是Spring AOP的底层原理。</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理<a id="more"></a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>角色分析：</p>
<ul>
<li>抽象角色：一般使用接口或者抽象类解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，可以做一些附属操作</li>
<li>客户：访问代理</li>
</ul>
<p>典型的静态代理步骤简单如下：</p>
<ul>
<li>为现有的每一个类都编写一个<strong>对应的</strong>代理类，并且让它实现和目标类相同的接口（假设都有）</li>
<li>在创建代理对象时，通过构造器或者setter函数塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后增加附属操作（比如打印日志）</li>
<li><strong>代理对象 = 增强代码 + 目标对象（原对象）</strong>，有了代理对象后，就不用原对象了</li>
</ul>
<p>实例代码如下，首先是抽象的接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后真实角色实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is delete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is query"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来编写静态代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    </span><br><span class="line">    UserServiceProxy()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UserServiceProxy(UserServiceImpl userService)&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log();</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log();</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log();</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log();</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before use"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真实角色</span></span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 代理角色</span></span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        <span class="comment">// 调用代理类方法</span></span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print "before use"</span></span><br><span class="line"><span class="comment">// print "this is add"</span></span><br></pre></td></tr></table></figure>

<p>代理模式的好处：</p>
<ul>
<li>可以使得真实角色更加纯粹，不用去关注一些公共业务</li>
<li>公共业务交给代理角色，实现了业务分工</li>
<li>公共业务发生扩展，方便修改</li>
</ul>
<p>静态代理缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量翻倍</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理利用java反射的原理，可以自动生成对应的的代理类。</p>
<ul>
<li>动态代理和静态代理的角色是一致的</li>
<li>动态代理的类是动态生成的，不是直接编码的</li>
<li>动态代理实现分为：基于接口的动态代理，基于类的动态代理<ul>
<li>基于接口-JDK动态代理【主要方法】</li>
<li>基于类-cglib</li>
<li>java字节码实现-Javassist</li>
</ul>
</li>
</ul>
<p>JDK动态代理需要了解两个类：</p>
<ul>
<li><code>java.lang.reflect.Proxy</code>，代理类<ul>
<li>提供创建动态代理类和实例的静态方法</li>
<li><code>newProxyInstance</code>是主要生成代理实例的方法，可以返回指定接口的代理类实例，并将方法调用分派给指定的调用处理程序，也就是InvocationHandler</li>
</ul>
</li>
<li><code>java.lang.reflect.InvocationHandler</code>，调用处理程序<ul>
<li>是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序，<strong>当代理实例调用方法的时候，方法调用将被编码并分配到其调用处理程序的invoke方法</strong></li>
<li>包含唯一的<code>invoke</code>方法，需实现它</li>
</ul>
</li>
</ul>
<p>实例代码如下，抽象的接口类和真实角色和上面一样，就先省略了，下面直接看动态代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用这个类自动生成代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理的接口类</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter方法传值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Proxy的静态方法，生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现InvocationHandler接口的唯一方法</span></span><br><span class="line">    <span class="comment">// 处理代理实例的方法，并返回结果</span></span><br><span class="line">    <span class="comment">// proxy参数看起来并未使用，其作用不是显式的，看资料说，只有proxy实例在InvocationHandler实现类里加载才能产生第二个参数method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真实角色</span></span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 代理角色</span></span><br><span class="line">        ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        pih.setTarget(userService);</span><br><span class="line">        <span class="comment">//动态生成代理类</span></span><br><span class="line">        UserService proxy = (UserService) pih.getProxy();</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "before add"</span></span><br><span class="line"><span class="comment">// print "this is add"</span></span><br></pre></td></tr></table></figure>

<p>动态代理的好处：</p>
<ul>
<li>一个动态代理类代理的是一个接口，一般就是对应的一类业务</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(9)-AOP的实现方式</title>
    <url>/2020/04/18/Spring%E5%9F%BA%E7%A1%80-9-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="关于AOP"><a href="#关于AOP" class="headerlink" title="关于AOP"></a>关于AOP</h2><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。通过预编译方式和运行时动态代理实现程序功能的统一维护的一种技术，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合降低。<a id="more"></a></p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/Program_Execution.jpg" alt="Program_Execution"></p>
<p>AOP需要掌握的几个概念：</p>
<ul>
<li>横切关注点：跨越应用程序的多个模块或功能，比如日志、安全、缓存等</li>
<li>切面（Aspect）：横切关注点被模块化的特殊对象，是一个类</li>
<li>通知（Advice）：切面完成的工作，是类中的方法</li>
<li>目标（Target）：被通知的对象，一般是业务中的接口或者方法</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象</li>
<li>切入点（PointCut）：切面通知执行的位置，在什么类的什么方法执行切入</li>
<li>连接点（JointPoint）：与切入点匹配的执行点，是各个业务方法的执行阶段</li>
</ul>
<p>Spring AOP中，通过Advice定义横切逻辑，支持5种类型的Advice。</p>
<table>
<thead>
<tr>
<th>通知类型</th>
<th>连接点</th>
<th>实现接口</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>方法前</td>
<td>org.springframework.aop.MethodBeforeAdvice</td>
</tr>
<tr>
<td>后置通知</td>
<td>方法后</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
</tr>
<tr>
<td>环绕通知</td>
<td>方法前后</td>
<td>org.aoppalliance.intercept.MethodInterceptor</td>
</tr>
<tr>
<td>异常抛出通知</td>
<td>方法抛出异常</td>
<td>org.springframework.aop.ThrowsAdvice</td>
</tr>
<tr>
<td>引介通知</td>
<td>类中增加新的方法属性</td>
<td>org.springframework.aop.IntroductionInterceptor</td>
</tr>
</tbody></table>
<h2 id="使用Springs实现AOP"><a href="#使用Springs实现AOP" class="headerlink" title="使用Springs实现AOP"></a>使用Springs实现AOP</h2><p>使用AOP功能，需要导入如下依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过简单案例了解其基础用法。</p>
<h3 id="使用Spring的API接口"><a href="#使用Spring的API接口" class="headerlink" title="使用Spring的API接口"></a>使用Spring的API接口</h3><p>首先新建业务接口<code>UserService</code>及其实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mx.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is delete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is query"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后利用AOP的java API新建两个日志类，分别在方法前和方法后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeLog</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 要执行的目标对象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(o.getClass().getName() + <span class="string">"的"</span> + method.getName() + <span class="string">"被执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 执行之后的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了"</span>  + method.getName() + <span class="string">"方法，返回结果为："</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用传统的xml文件进行bean，切点的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.mx.service.UserServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beforeLog"</span> <span class="attr">class</span>=<span class="string">"com.mx.log.BeforeLog"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.mx.log.AfterLog"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点，expression填入一个execution表达式，表示要执行的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.mx.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行环绕增加，哪个方法类作用在哪个切点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"beforeLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"afterLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后新建测试类查看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mx.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        <span class="comment">// 动态代理的是接口</span></span><br><span class="line">        UserService userService = context.getBean(<span class="string">"userService"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print "com.mx.service.UserServiceImpl的add被执行了"</span></span><br><span class="line"><span class="comment">// print "this is add"</span></span><br><span class="line"><span class="comment">// print "执行了add方法，返回结果为：null"</span></span><br></pre></td></tr></table></figure>

<p>可以看到，AOP在完全没有改动原来业务逻辑的情况下，通过动态代理实现了日志这种附加逻辑。</p>
<h3 id="使用自定义类"><a href="#使用自定义类" class="headerlink" title="使用自定义类"></a>使用自定义类</h3><p>首先自定义自己的切面类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.diy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----方法执行前------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----方法执行后------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在<code>beans.xml</code>进行自定义切面的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方法二：自定义类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"diy"</span> <span class="attr">class</span>=<span class="string">"com.mx.diy.Diy"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--自定义切面，ref为引用的类--&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"diy"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.mx.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通知，也有的翻译为增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行测试类之后的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-----方法执行前------</span><br><span class="line"><span class="keyword">this</span> is add</span><br><span class="line">-----方法执行后------</span><br></pre></td></tr></table></figure>

<p>这种自定义切面的方式比较简单，但是无法获取类中方法的内部信息。</p>
<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>首先在<code>beans.xml</code>开启bean包扫描和aop的注解支持：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.mx.diy"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop的注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写自定义切面类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.diy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 标注这个类是一个切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置切入点和连接点</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.mx.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====方法执行前====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.mx.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====方法执行后======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试类之后的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=====方法执行前=====</span><br><span class="line"><span class="keyword">this</span> is add</span><br><span class="line">=====方法执行后======</span><br></pre></td></tr></table></figure>

<p>各个连接点的执行顺序从先到后如下：</p>
<ul>
<li>环绕前</li>
<li>方法执行前</li>
<li>环绕后</li>
<li>方法执行后</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web中的过滤器和拦截器</title>
    <url>/2020/06/13/Spring-Web%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<p>Java Web有三大器，也就是监听器、过滤器和拦截器，今天我们来对其中的过滤器和拦截器做分析比较</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>过滤器，顾名思义是起到过滤筛选作用的一种东西，在Spring程序中，过滤器过滤的对象是客户端访问的web资源，也可以理解成一种预处理手段，对资源进行拦截后，将其中我们认为的杂质（用户自定义的）进行过滤，符合条件的放行，不符合的则拦截下来。</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/java%E8%BF%87%E6%BB%A4%E5%99%A8.jpg" alt="java过滤器"></p>
<p>过滤器可以拦截request，也可以拦截返回的response，当浏览器发送请求到服务器时，先执行过滤器，然后才访问Web资源。服务器响应Response，从Web资源抵达浏览器之前，也会途径过滤器。</p>
<p>使用过滤器的主要场景是：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。</li>
<li>当 Servlet 容器发现已经注册了 Filter 程序，那么容器会<strong>优先调用 Filter 的 doFilter 方法</strong>（可以去激活目标 Servlet 的 service 方法），再由 doFilter 方法决定是否去激活 service 方法。</li>
<li>只要<strong>在过滤器的 FilterChain.doFilter 方法的前后</strong>增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。</li>
<li>如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。</li>
<li>多个Filter可以组成Filter链，其执行顺序和配置相关</li>
</ul>
<h3 id="FIlter接口"><a href="#FIlter接口" class="headerlink" title="FIlter接口"></a>FIlter接口</h3><p>过滤器类实现的是<code>javax.servlet.Filter</code>接口，看一下<code>javax.servlet.Filter</code>接口，定义了三个方法，分别如下：</p>
<blockquote>
<ol>
<li>public void init(FilterConfig filterConfig)</li>
</ol>
</blockquote>
<p>Filter 的初始化，在 Servlet 容器创建过滤器实例的时候调用，以确保过滤器能够正常工作，该方法在声明周期中只能被执行一次。</p>
<blockquote>
<ol start="2">
<li>public void doFilter (ServletRequest request, ServletResponse response, FilterChain chain)</li>
</ol>
</blockquote>
<p>Filter 的核心方法，用于对每个拦截到的请求做一些设定好的操作。request和response参数为传递过来的请求和响应对象，chian为当前Filter链的对象。</p>
<blockquote>
<ol start="3">
<li>public void destroy()</li>
</ol>
</blockquote>
<p>Filter 的销毁，在 Servlet 容器销毁过滤器实例时调用，以释放其占用的资源。只有在 doFilter() 方法中的所有线程退出或超时后，web 容器才会调用此方法。</p>
<h3 id="实现自己的过滤器"><a href="#实现自己的过滤器" class="headerlink" title="实现自己的过滤器"></a>实现自己的过滤器</h3><ul>
<li>添加pom依赖</li>
</ul>
<p><code>javax.servlet.Filter</code>无需手动添加pom项目，只要spring boot引入了web组件即可</p>
<ul>
<li>编写controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/api"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">first</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写两个过滤器类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"First,检验接口是否被调用，尝试获取contentType如下： "</span> + response.getContentType());</span><br><span class="line">        chain.doFilter(request, response);<span class="comment">//这步使得请求能够继续传导下去，如果没有的话，请求就在此结束</span></span><br><span class="line">        System.out.println(<span class="string">"First,检验接口是否被调用，尝试获取contentType如下： "</span> + response.getContentType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Second,检验接口是否被调用，尝试获取contentType如下： "</span> + response.getContentType());</span><br><span class="line">        chain.doFilter(request, response);<span class="comment">//这步使得请求能够继续传导下去，如果没有的话，请求就在此结束</span></span><br><span class="line">        System.out.println(<span class="string">"Second,检验接口是否被调用，尝试获取contentType如下： "</span> + response.getContentType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写配置类</li>
</ul>
<p>spring早期时候，Filter主要是通过web.xml进行配置的，现在spring boot的配置方法主要有两种，一种是自定义配置类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mx.demo.filter.FirstFilter;</span><br><span class="line"><span class="keyword">import</span> com.mx.demo.filter.SecondFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;FirstFilter&gt; <span class="title">firstFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;FirstFilter&gt; filterRegBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        filterRegBean.setFilter(<span class="keyword">new</span> FirstFilter());</span><br><span class="line">        filterRegBean.addUrlPatterns(<span class="string">"/api/*"</span>); <span class="comment">// 匹配模式</span></span><br><span class="line">        filterRegBean.setOrder(<span class="number">1</span>); <span class="comment">// 执行顺序，数字小的先执行</span></span><br><span class="line">        <span class="keyword">return</span> filterRegBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;SecondFilter&gt; <span class="title">secondFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;SecondFilter&gt; filterRegBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        filterRegBean.setFilter(<span class="keyword">new</span> SecondFilter());</span><br><span class="line">        filterRegBean.addUrlPatterns(<span class="string">"/api/*"</span>); <span class="comment">// 匹配模式</span></span><br><span class="line">        filterRegBean.setOrder(<span class="number">2</span>); <span class="comment">// 执行顺序</span></span><br><span class="line">        <span class="keyword">return</span> filterRegBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的好处在于可以集中配置。</p>
<p>另一种则是使用<code>@WebFilter</code>和<code>@Order</code>的注解，能够在每个Filter之上进行配置，减少代码量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">10</span>) <span class="comment">// 设置优先级</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"firstFilter"</span>, urlPatterns = <span class="string">"/api/*"</span>)  <span class="comment">// 设置匹配模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"First,检验接口是否被调用，尝试获取contentType如下： "</span> + response.getContentType());</span><br><span class="line">        chain.doFilter(request, response);<span class="comment">//这步使得请求能够继续传导下去，如果没有的话，请求就在此结束</span></span><br><span class="line">        System.out.println(<span class="string">"First,检验接口是否被调用，尝试获取contentType如下： "</span> + response.getContentType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还需要在启动类中增加注解<code>@ServletComponentScan</code>。</p>
<ul>
<li>执行效果，控制台会打印如下信息：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">First,检验接口是否被调用，尝试获取contentType如下： null</span><br><span class="line">Second,检验接口是否被调用，尝试获取contentType如下： null</span><br><span class="line">Second,检验接口是否被调用，尝试获取contentType如下： text/plain;charset=UTF-8</span><br><span class="line">First,检验接口是否被调用，尝试获取contentType如下： text/plain;charset=UTF-8</span><br></pre></td></tr></table></figure>

<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>当我们配置了多个 filter，且一个请求能够被多次拦截时，该请求将沿着 <code>客户端 -&gt; 过滤器1 -&gt; 过滤器2 -&gt; servlet -&gt; 过滤器2 -&gt; 过滤器1 -&gt; 客户端</code> 链式流转，如下图所示 ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/Filter%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8.jpg" alt="Filter链式调用"></p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>拦截器是 AOP 的一种实现策略，用于在某个方法或字段被访问前对它进行拦截，然后在其之前或之后加上某些操作。同filter一样，interceptor也是链式调用。每个interceptor的调用会依据它的声明顺序依次执行。</p>
<p>拦截器的主要使用场景</p>
<ul>
<li><p>日志记录：记录请求信息的日志，以便进行信息监控、信息统计等</p>
</li>
<li><p>权限检查：如登录检测，进入处理器检测检测是否登录</p>
</li>
<li><p>性能监控：通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间</p>
</li>
</ul>
<h3 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a>HandlerInterceptor接口</h3><p>拦截器实现的是HandlerInterceptor接口，该接口定义了三个方法，分别如下：</p>
<blockquote>
<ol>
<li>preHandler(HttpServletRequest request, HttpServletResponse response, Object handler)</li>
</ol>
</blockquote>
<p>方法将在<strong>请求处理之前</strong>进行调用。SpringMVC中的<code>Interceptor</code>同Filter一样都是<strong>链式调用</strong>。每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor中的preHandle方法.</p>
<blockquote>
<ol start="2">
<li>postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</li>
</ol>
</blockquote>
<p>在当前<strong>请求进行处理之后</strong>，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。</p>
<blockquote>
<ol start="3">
<li>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)</li>
</ol>
</blockquote>
<p>该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet <strong>渲染了对应的视图之后执行</strong>。这个方法的主要作用是用于进行资源清理工作的。</p>
<h3 id="实现自己的拦截器"><a href="#实现自己的拦截器" class="headerlink" title="实现自己的拦截器"></a>实现自己的拦截器</h3><ul>
<li>添加配置类，同上</li>
<li>编写controller</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/api"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/world"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">world</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写2个拦截器，其中第一个的功能是打印请求的执行时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是第1个拦截器"</span>);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandler是请求结束执行的，但只有preHandle方法返回true的时候才会执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Interceptor cost="</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个拦截器的功能是为登录用户跳转login</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是第2个拦截器"</span>);</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//用户已登录</span></span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">"user"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//用户未登录，直接跳转登录页面</span></span><br><span class="line">            response.sendRedirect(<span class="string">"/api/login"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mx.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mx.demo.interceptor.FirstInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.mx.demo.interceptor.SecondInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.AutoConfigureOrder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FirstInterceptor firstInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SecondInterceptor secondInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.加入的顺序就是拦截器执行的顺序，</span></span><br><span class="line">        <span class="comment">// 2.按顺序执行所有拦截器的preHandle</span></span><br><span class="line">        <span class="comment">// 3.所有的preHandle 执行完再执行全部postHandle 最后是postHandle</span></span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">"/api/**"</span>);</span><br><span class="line">        registry.addInterceptor(secondInterceptor).addPathPatterns(<span class="string">"/api/**"</span>).excludePathPatterns(<span class="string">"/api/login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用接口，得到执行结果</li>
</ul>
<p>如果请求的是<code>/api/hello</code>，那么会被重定向到<code>/api/login</code>里头：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">这是第1个拦截器</span><br><span class="line">这是第2个拦截器</span><br><span class="line">这是第1个拦截器</span><br><span class="line">Interceptor cost=23</span><br></pre></td></tr></table></figure>

<p>如果请求的是<code>/api/hello</code>，则只会打印如下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">这是第1个拦截器</span><br><span class="line">Interceptor cost=2</span><br></pre></td></tr></table></figure>

<h3 id="链式调用-1"><a href="#链式调用-1" class="headerlink" title="链式调用"></a>链式调用</h3><p>拦截器的链式调用方式和过滤器十分相似</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8.png" alt=""></p>
<h3 id="混合后的调用顺序"><a href="#混合后的调用顺序" class="headerlink" title="混合后的调用顺序"></a>混合后的调用顺序</h3><p>如果一个spring工程中既有过滤器，又有拦截器，那么他们的执行顺序如下图，可见拦截器的执行是在过滤器的包围之中的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg" alt=""></p>
<h2 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h2><p>如果我们去网上查找过滤器和拦截器的区别，多半会得到以下答案：</p>
<ol>
<li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li>
<li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li>
<li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li>
<li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li>
<li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li>
</ol>
<p>以上基于技术实现的角度，如果我们想更加直观的理解二者的区别和联系，可以从设计模式出发：</p>
<ul>
<li>过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。</li>
</ul>
<p>过滤器换一种表达就是预处理（pre processing）或者后处理（post processing），举个例子，煮饭之前用水先对米进行清洗，这就是预处理；榨完果汁后用筛子将果渣过滤掉，这就是后处理。<strong>对数据进行预处理或者后处理就是过滤器要做的工作</strong>，常见的应用有将请求中的数据进行转码，日志系统，系统缓存这些都是要依赖过滤器来实现，当有多个过滤器时就形成了过滤器链，也就是要依次经过过滤器链中的过滤器才能最终到达实际目标.</p>
<ul>
<li>拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。</li>
</ul>
<p>拦截器顾名思义，就是对数据进行拦截，从这个定义上看，似乎和过滤器很像，<strong>但是拦截器要做的工作更多是安全方面</strong>，比如用户验证、判断是否登陆。和过滤器的一个区别就是拦截器不一定会到达目标，也就是可以拒绝你的请求，但是过滤器写出来后一般是会到达目标的，只是在到达目标前或者后要进行一些操作。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本命令</title>
    <url>/2020/03/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="系统操作命令"><a href="#系统操作命令" class="headerlink" title="系统操作命令"></a>系统操作命令</h2><ul>
<li><code>startx</code>: 启动X window界面。 - P115</li>
<li><code>exit</code>: 注销Linux，并非关机而是离开系统。同时，这个命令也是退出远程登录界面的命令，可以用于退出root用户，可以用于关闭当前终端。 - P117</li>
<li><code>data</code>: 显示日期与时间。 - P118  <a id="more"></a></li>
<li><code>cal</code>: 显示日历。 - P118</li>
<li><code>bc</code>: 计算器软件。 - P120</li>
<li><code>man</code>: 求助功能。 - P122</li>
<li><code>info</code>: 求助功能。 - P128</li>
<li><code>who</code>: 用于查询当前有谁在线。 - P131</li>
<li><code>netstat</code>: 用于查询当前网络状态。 - P131  </li>
<li><code>ps -aux</code>: 用于查询当前后台执行程序情况。 - P131</li>
<li><code>shutdown</code>: 关机。 - P131</li>
<li><code>reboot</code>: 重启。 - P132</li>
<li><code>halt</code>: 关机。 - P132</li>
<li><code>poweroff</code>: 关机。 - P132</li>
<li><code>sync</code>: 数据同步写入磁盘，正常关机时关机命令会调用这条指令。 - P132</li>
<li><code>init</code>: 切换执行等级。 - P133</li>
</ul>
<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><ul>
<li><code>ls</code>: 显示文件的文件名与相关属性(list)。常用参数：-a 显示所有文件，包括隐藏文件；-l 显示文件详细信息，包括文件属性与权限，修改时间等。 - P167</li>
<li><code>chgrp</code>: 改变文件或目录的所属用户组(change group)。常用参数：-R 进行递归的持续更改，即更改当前目录与下级所有子目录与文件的所属用户组。 - P144</li>
<li><code>chown</code>: 改变文件或目录的所有者(change owner)。常用参数：-R 进行递归的持续更改。 - P145</li>
<li><code>chmod</code>: 改变文件或目录权限。常用参数：-R 进行递归的持续更改。 -P146</li>
<li><code>cp</code>: 复制命令(copy)。常用参数：<code>-i</code>互动，当目标文件以及存在时，在覆盖前询问操作是否进行；<code>-r</code>递归持续复制，用于复制目录；<code>-p</code>连同文件的属性一起复制，而不是使用默认属性；<code>-u</code>若被复制源文件比目标文件新才会复制 - P169</li>
<li><code>rm</code>: 移除文件或目录(remove)。参数：<code>-r</code>递归删除，会删除掉整个目录（不管是否为空）；<code>-i</code>互动，会在删除前提示是否需要操作。 - P171</li>
<li><code>mv</code>: 移动文件与目录、或重命名文件(move)。参数：<code>-i</code>互动，如果目标已经存在，则询问是否需要覆盖；<code>-u</code>若目标已经存在，且比被移动源文件旧，才会覆盖。 - P172</li>
<li><code>cd</code>: 切换目录(change directory)。常用命令：<code>cd -</code> 回到刚才的目录；<code>cd ~</code>回到自己的主文件夹，同<code>cd</code>；<code>cd ..</code>回到上层路径；<code>cd /</code>回到根目录。- P163</li>
<li><code>pwd</code>: 显示目前所在的目录(print working directory)。常用参数：<code>-P</code>显示出当前路径，而非使用连接路径。 - P164</li>
<li><code>mkdir</code>: 新建新目录(make directory)。参数：<code>-p</code>创建多级目录；<code>-m</code>给予新目录权限。 - P164</li>
<li><code>rmdir</code>: 删除“空”目录(remove directory)，注意只能是空目录。 - P165</li>
</ul>
<h3 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h3><ul>
<li><code>cat</code>: 查看一个文件的内容(concatenate)。参数：<code>-n</code>打印出行号，连同空白行也会有行号；<code>-b</code>打印出行号，空白行没有行号；<code>-A</code>可以显示出来一些特殊字符，而不是空白。 - P173</li>
<li><code>tac</code>: 反向列出一个文件的内容，从最后一行到第一行。 - P174</li>
<li><code>nl</code>: 添加行号打印。 - P174</li>
<li><code>more</code>: 翻页命令。指令：<code>[Space]</code>向下翻一页；<code>[Enter]</code>向下翻一行；<code>/字符串</code>向下查询该字符串；<code>q</code>离开more；<code>b</code>往上翻页；<code>n</code>查询过程中查询下一条。 - P175</li>
<li><code>less</code>: 翻页命令，比more人性化。指令：<code>[Space]</code>向下翻一页；<code>[PageDown]</code>向下翻动一页；<code>[PageUp]</code>向上翻动一页；<code>/字符串</code>向下查询该字符串；<code>?字符串</code>向上查询该字符串；<code>n</code>重复查询；<code>N</code>重复查询，与n相反；<code>q</code>离开less。 - P176</li>
<li><code>head</code>: 取出前边几行。参数：<code>-n</code>后边接数字，代表取出几行。 - P176</li>
<li><code>tail</code>: 取出后边几行。参数：<code>-n</code>后边接数字，代表取出最后几行。 - P177</li>
<li><code>od</code>: 读取非纯文本文件。参数：<code>-t</code>后边可以接各种类型的输出。 - P177</li>
<li><code>touch</code>: 修改文件时间或创建新文件。 -P180</li>
</ul>
<h3 id="文件默认权限与隐藏属性"><a href="#文件默认权限与隐藏属性" class="headerlink" title="文件默认权限与隐藏属性"></a>文件默认权限与隐藏属性</h3><ul>
<li><code>umask</code>: 查看和修改系统默认文件权限。参数：<code>-S</code>将权限以符号形式显示。 - P181</li>
<li><code>chattr</code>: 设置文件的隐藏属性。 - P183</li>
<li><code>lsattr</code>: 显示文件的隐藏属性。 - P184</li>
<li><code>file</code>: 查看文件类型。 - P187</li>
</ul>
<h3 id="命令与文件的查询"><a href="#命令与文件的查询" class="headerlink" title="命令与文件的查询"></a>命令与文件的查询</h3><ul>
<li><code>which</code>: 寻找执行文件。 参数：<code>-a</code>将所有在PATH中可以找到的该命令均列出来，而不是找到的第一条。 - P187</li>
<li><code>whereis</code>: 寻找特定文件，通过数据库查询，所以速度快，但并不是所有文件都在数据库中注册，刚新建的文件可能还没有在数据库中注册，刚删除的文件也不会立即从数据库中消失。 - P188</li>
<li><code>locate</code>: 寻找特定文件，与whereis不同的是，可以输入部分文件名查找包含这部分名称的所有文件，与whereis相同，也是查询数据库。</li>
<li><code>updatedb</code>: 可以用来更新数据库。 - P189</li>
<li><code>find</code>: 寻找特定文件，该命令是在硬盘里查找所有文件，所以耗时长。参数比较多，请查阅原文。 - P189</li>
</ul>
<h2 id="磁盘与文件系统管理"><a href="#磁盘与文件系统管理" class="headerlink" title="磁盘与文件系统管理"></a>磁盘与文件系统管理</h2><h3 id="磁盘与目录容量"><a href="#磁盘与目录容量" class="headerlink" title="磁盘与目录容量"></a>磁盘与目录容量</h3><ul>
<li><code>df</code>: 列出文件系统的整体磁盘使用量。重要参数：<code>-h</code>以人类较易阅读的存储单位显示容量；<code>-i</code>不用硬盘容量而是用inode数量显示；<code>-a</code>列出所有文件系统；<code>-T</code>将该分区的文件系统名称一并列出。 - P210</li>
<li><code>du</code>: 评估文件系统的磁盘使用量。重要参数：<code>-s</code>仅列出总量，而不列出每个个别目录的占用容量。 - P212</li>
</ul>
<h3 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h3><ul>
<li><code>ln</code>: 设置连接文件。重要参数：<code>-s</code>添加该参数意味着进行symbolic link，而不添加参数意味着进行hard link。</li>
</ul>
<h3 id="磁盘的分区、格式化、检验与挂载"><a href="#磁盘的分区、格式化、检验与挂载" class="headerlink" title="磁盘的分区、格式化、检验与挂载"></a>磁盘的分区、格式化、检验与挂载</h3><ul>
<li><code>fdisk</code>: 程序，磁盘分区工具。重要命令：<code>d</code>删除一个分区；<code>n</code>增加一个新分区；<code>p</code>在屏幕上显示分区；<code>q</code>退出程序并不保存；<code>w</code>退出程序并保存（将之前的设置写入分区表）。 - P217</li>
<li><code>mkfs</code>: 格式化命令，它会调用正确的文件系统格式化工具软件。参数：<code>-t</code>可以接文件系统格式。 - P223</li>
<li><code>mke2fs</code>: 了解EXT2/EXT3的公用程序。 - P224</li>
<li><code>fsck</code>: 磁盘检验命令(file system check)，检查修正文件系统错误。执行该命令时，被检查的分区务必不可挂载到系统上，即需要在卸载的状态下。 - P225</li>
<li><code>badblocks</code>: 检查硬盘扇区是否有坏轨。 - P226</li>
<li><code>mount</code>: 挂载命令。 - P227</li>
<li><code>umount</code>: 卸载命令。 - P230</li>
<li><code>mknod</code>: 设置磁盘参数。 - P231</li>
<li><code>e2lable</code>: 修改磁盘卷标。 - P232</li>
<li><code>tune2fs</code>: 更新磁盘格式。 - P232</li>
<li><code>hdparm</code>: IDE硬盘参数设置。 - P233</li>
</ul>
<h2 id="文件压缩与打包"><a href="#文件压缩与打包" class="headerlink" title="文件压缩与打包"></a>文件压缩与打包</h2><h3 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h3><ul>
<li><code>compress</code>: 比较老旧的一款压缩软件，处理<code>.Z</code>型压缩文件，现在不常用。 - P251</li>
<li><code>uncompress</code>: 对应的解压缩。 - P251</li>
<li><code>gzip</code>: 应用比较广泛，处理<code>.gz</code>型压缩文件。参数：<code>-c</code>将压缩数据输出到屏幕，也可通过数据流重定向；<code>-d</code>解压缩命令；<code>-v</code>显示压缩信息；<code>-#</code>压缩等级，#可取1到9，1最快，默认为6。 - P252</li>
<li><code>gunzip</code>: 对应的解压缩软件，与命令<code>gzip -d abc.gz</code>相同。 - P252</li>
<li><code>zcat</code>: 查看<code>.gz</code>压缩格式的文件内容，直接打开cat。 - P252</li>
<li><code>bzip2</code>: 应用比较广泛，压缩率比<code>gzip</code>高，处理<code>.bz</code> <code>.bz2</code> <code>.tbz</code> <code>.tbz2</code>型压缩文件。参数：<code>-c</code>将压缩数据输出到屏幕，也可通过数据流重定向；<code>-d</code>解压缩命令；<code>-k</code>保留源文件而不会删除源文件；<code>-v</code>显示压缩信息；<code>-#</code>压缩等级，#可取1到9，同上。 - P253</li>
<li><code>bunzip2</code>: 对应的解压缩软件，与命令<code>bzip2 -d abc.bz2</code>相同。 - P253</li>
<li><code>bzcat</code>: 查看<code>.bz2</code>等压缩格式的文件内容，直接打开cat。 - P253</li>
</ul>
<h3 id="打包指令"><a href="#打包指令" class="headerlink" title="打包指令"></a>打包指令</h3><ul>
<li><code>tar</code>: 打包命令，将多个文件打包成一个文件后压缩，参数比较多，请参见原文。常见指令：<code>tar -jcv -f abc.tar.bz2 abc/</code>压缩abc目录到abc.tar.bz2；<code>tar -jtv -f abc.tar.bz2</code>查看该压缩打包文件中有哪些文件名；<code>tar -jxv -f abc.tar.gz2 -C abc/</code>将abc.tar.gz2解压到目录abc/中。 - P254</li>
</ul>
<h3 id="备份指令"><a href="#备份指令" class="headerlink" title="备份指令"></a>备份指令</h3><ul>
<li><code>dump</code>: 备份文件系统。参数：<code>-u</code>将该次备份时间记录到/etc/dumpdateS文件中；<code>-v</code>显示详细信息；<code>-j</code>加入bzip2支持，将备份数据压缩，默认等级为2；<code>-level</code>等级。 - P260</li>
<li><code>restore</code>: 对应的恢复指令。参数：<code>-t</code>查看备份文件数据；<code>-C</code>比较备份数据与实际文件；<code>-i</code>互动模式。 - P262</li>
</ul>
<h3 id="光盘写入工具"><a href="#光盘写入工具" class="headerlink" title="光盘写入工具"></a>光盘写入工具</h3><ul>
<li><code>mkisofs</code>: 将文件制作成iso格式镜像文件。 - P265</li>
<li><code>cdrecord</code>: 光盘刻录工具，可以刻录到光盘。 - P267</li>
</ul>
<h3 id="其他压缩与备份工具"><a href="#其他压缩与备份工具" class="headerlink" title="其他压缩与备份工具"></a>其他压缩与备份工具</h3><ul>
<li><code>dd</code>: 读取磁盘设备内容并备份，备份整块分区或磁盘，参数比较多，请参见原文。 - P269</li>
<li><code>cpio</code>: 可以备份任何东西，但需要配合find来找到文件名，详细使用情况见原文。 - P270</li>
</ul>
<h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><ul>
<li><code>LANG=zh_CN.big5</code>: 修正终端语系为big5编码。另外还有gb2312、tfg8编码。 - P290</li>
<li><code>dos2UNIX</code>: 格式转换命令，将DOS格式的文件转换为UNIX格式文件。参数：<code>-k</code>保留该文件原本的mtime时间格式；<code>-n</code>保留原格式的文件，将转换的文件输出到新内容，需要加新文件名。 - P290</li>
<li><code>UNIX2dos</code>: 格式转换命令，将UNIX格式的文件转换为DOS格式文件。参数同<code>dos2UNIX</code>。 - P290</li>
<li><code>iconv</code>: 格式转换指令，可以选择转换成支持的任何格式。参数：<code>--list</code>列出所有支持的格式；<code>-f</code>后接源文件的编码格式；<code>-t</code>后接新的要转换的编码格式；<code>-o</code>如果需要保留源文件，用该参数后接新文件名，可以新建编码文件。 - P291</li>
</ul>
<h2 id="认识与学习bash"><a href="#认识与学习bash" class="headerlink" title="认识与学习bash"></a>认识与学习bash</h2><h3 id="bash内置命令"><a href="#bash内置命令" class="headerlink" title="bash内置命令"></a>bash内置命令</h3><ul>
<li><code>type [-tpa] name</code>: 可以查看某个命令是外部命令还是内部命令。参数：<code>-t</code>显示命令的意义。 - P298</li>
</ul>
<h3 id="shell的变量功能"><a href="#shell的变量功能" class="headerlink" title="shell的变量功能"></a>shell的变量功能</h3><ul>
<li><code>echo $variable</code>: 可以查看变量内容，对于该变量的使用特别灵活，请逐步摸索。 - P300 -P313</li>
<li><code>unset name</code>: 取消刚才设置的name变量。 - P303</li>
<li><code>env</code>: 列出所有环境变量与常见环境变量说明。 - P304</li>
<li><code>set</code>: 查看所有变量，包括环境变量与自定义变量。 - P305</li>
<li><code>export variable</code>:　将variable自定义变量变成环境变量，另外，如果不接任何变量使用export，则会把所有环境变量显示出来。 - P308</li>
<li><code>locale [-a]</code>: 查看语系变量。参数<code>-a</code>显示所有语系变量。 - P308</li>
<li><code>read [-pt] variable</code>: 读取来自键盘输入的变量。参数：<code>-p</code>在输入光标前显示可以设置的提示内容，提示内容接到参数后边；<code>-t</code>设置读取等待时间，单位秒，等待时间之后跳过该次读取。 - P310</li>
<li><code>declare [-aixr] variable</code>: 声明变量的类型，如果不接任何参数，则显示所有变量名称和内容。参数：<code>-a</code>将后面名为variable的变量定义为数组类型，默认变量是字符串类型；<code>-i</code>定义为整数数字类型；<code>-x</code>将variable变成环境变量，同export；<code>-r</code>将变量设置为readonly类型，该变量不可更改内容，也不能重设。 - P311</li>
<li><code>ulimit [-SHacdfltu] [配额]</code>: 用于限定用户可使用的系统资源。变量过多，请查阅原文。 - P316</li>
</ul>
<h3 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="headerlink" title="命令别名与历史命令"></a>命令别名与历史命令</h3><ul>
<li><code>alias 命令别名=命令序列</code>: 可以用命令别名取代比较长的命令序列串。 - P317</li>
<li><code>unalias 命令别名</code>: 取消命令别名。 - P318</li>
<li><code>history [n/-c/-raw histfiles]</code>: 历史命令。参数：<code>n</code>列出最近几行命令；<code>-c</code>将当前shell中的所有历史命令列出；<code>-a</code>将新增的命令加入到histfiles文件中，若没有histfiles，则默认写入到/.bash_history；<code>-r</code>将histfiles的内容读入当前这个shell的history记忆中；<code>-w</code>将当前history的记忆写入到histfiles中。 - P318</li>
</ul>
<h3 id="bash-shell操作环境"><a href="#bash-shell操作环境" class="headerlink" title="bash shell操作环境"></a>bash shell操作环境</h3><ul>
<li><code>source 配置文件名</code>: 可以将配置文件的内容读入到目前的shell环境中，而不需要在更改了shell之后重新注销再登录。 - P324</li>
<li><code>stty [-a]</code>: 查看终端机输入按键代表的意义。参数：<code>-a</code>将目前所有的stty参数列出来。 - P325</li>
<li><code>set [-vcCHhmBx]</code>: 设置一些变量，配置输入输出环境等。参数比较多，请查阅原文。 - P326</li>
</ul>
<h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><ul>
<li><code>cmd1 ; cmd2</code>: 通过<code>;</code>来连接两个命令，代表不需要考虑命令相关性的连续命令执行。 - P332</li>
<li><code>cmd1 &amp;&amp; cmd2</code>: 通过<code>&amp;&amp;</code>来连接两个命令，代表考虑相关性，并且cmd1正确执行则cmd2才执行，cmd1错误则不执行cmd2。 - P332</li>
<li><code>cmd1 || cmd2</code>: 通过<code>||</code>来连接两个命令，代表考虑相关性，并且cmd1正确执行则cmd2不执行，cmd1错误则cmd2执行。 - P332</li>
</ul>
<h3 id="管道命令（pipe"><a href="#管道命令（pipe" class="headerlink" title="管道命令（pipe)"></a>管道命令（pipe)</h3><ul>
<li><code>cmd1 | cmd2</code>: 通过<code>|</code>来实现管道命令，需要注意的是，每个管道后面接的第一个数据必须是命令，而且这个命令必须是能够接收stdin的数据才行，管道对stderr没有直接处理的能力。 - P334</li>
<li><code>cut -d &#39;分隔字符&#39; -f fields</code>或<code>cut -c 字符范围</code>: 用于使用<code>分隔字符</code>来分隔文段字符；后者用于排列整齐的信息。 - P335</li>
<li><code>grep [-acinv] [--color=auto] &#39;查找字符串&#39; filename</code>: 分析一行信息，若当中有我们所需要的信息，就将该行拿出来。参数：<code>-a</code>将binary文件以text文件的方式查找数据；<code>-c</code>计算找到’查找字符串’的次数；<code>-i</code>忽略大小写的不同；<code>-n</code>顺便输出行号；<code>-v</code>反向选择，显示不包括’查找字符串’内容的那一行；<code>--color=auto</code>将找到行的关键词加颜色显示。 - P336</li>
<li><code>sort [-fbMnrtuk] [file or stdin]</code>: 用于排序，可以依据不同的数据类型排序。参数比较多，请查阅原文。 - P336</li>
<li><code>uniq [-ic]</code>: 将排序后重复的数据仅列出一个显示。参数：<code>-i</code>忽略大小写字符；<code>-c</code>进行计数。 -P337</li>
<li><code>wc [-lwm]</code>: 计算输出的信息的整体数据量。参数：<code>-l</code>仅列出列数；<code>-w</code>仅列出字数；<code>-m</code>列出多少字符。 - P337</li>
<li><code>tee [-a] file</code>: 双向重定向。参数：<code>-a</code>以累加的方式，将数据加入到file文件中。就是同时写入到文件也可以打印到屏幕。 -P338</li>
<li><code>tr [-ds] set1 ...</code>: 可以用来删除一段信息中的文字，或进行文字信息的替换。参数：<code>-d</code>删除信息中的set1等字符串；<code>-s</code>替换掉重复的字符串。 - P338</li>
<li><code>col [-xb]</code>: 具有和tr类似的功能，此外，col经常被用来利用于将man page转存成纯文本格式文件以方便查阅。参数：<code>-x</code>将TAB键换成对等的空格键；<code>-b</code>将文字内有反斜杠/时，仅保留反斜杠最后接的那个字符。 - P339</li>
<li><code>join [-ti12] file1 file2</code>: 主要用于将两个文件当中有相同数据的那一行加起来。参数不聊，请查阅原文。 - P340</li>
<li><code>paste [-d] file1 file2</code>: join必须要对比两个文件的相关性，但是paste就是直接将两行贴在一起，且中间用TAB键隔开。参数：<code>-d</code>后面接分隔字符，默认以TAB键隔开。 - P341</li>
<li><code>expand [-t] file</code>: 就是将TAB键转成空格键。参数：<code>-t</code>后面接数字，设定一个TAB替换成几个空格。 - P431</li>
<li><code>split [-bl] file PREFIX</code>: 可以将一个大文件依据文件大小或行数来切割成小文件。参数：<code>-b</code>后面可以接切割成的文件大小，可加单位；<code>-l</code>以行数来切割。 - P342</li>
<li><code>xargs [-0epn] command</code>: 产生某个命令的参数。参数不聊，请查阅原文。 - P342</li>
</ul>
<h2 id="程序管理和SELinux初探"><a href="#程序管理和SELinux初探" class="headerlink" title="程序管理和SELinux初探"></a>程序管理和SELinux初探</h2><h3 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h3><ul>
<li><code>jobs</code> ：查看目前的后台工作状态。参数：<code>-l</code> 同时列出PID号码；<code>-r</code> 仅列出正在后台的工作；<code>-s</code> 仅列出在后台中暂停的工作。-p513</li>
<li><code>fg %jobnum</code> ：将后台工作拿到前台来处理。参数：<code>jobnum</code> 工作号码，一个数字。-p513</li>
<li><code>bg %jobnum</code> ：让工作在后台的状态变成前台运行。-p513</li>
</ul>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul>
<li><code>ps</code>：报告当前系统的进程状态，选项多得离谱。常用参数：<code>-l</code> 列出仅和当前bash相关的进程；<code>aux</code> 列出目前所有在内存中的进程。-p516</li>
<li><code>top</code> ：动态查看进程变化。参数：<code>-d</code> 后面接数字，表示刷新时间，按秒来计算。-p518</li>
<li><code>pstree</code> ：查看进程相关性。参数：<code>-A</code> 进程树以ASCII字符连接；<code>-p</code> 同时列出每个进程的PID；<code>-u</code> 同时列出每个进程所属的账号名称。-p520</li>
<li><code>kill [-signal] PID</code> ：给进程一个命令，管理进程。参数：<code>-9</code> 强制关闭；<code>-1</code> 重启进程；<code>-2</code> 中断进程（ctrl-c）；<code>-i</code> 交互，操作前会有提示。-p522</li>
<li><code>free</code> ：查看内存使用情况。参数：<code>-b|-k|-m|-g</code> 存储单位，从Bite到GB。-p525</li>
<li><code>uname</code> ：查看系统和内核相关信息。参数：<code>-a</code> 所有系统相关信息都会列出。-p526</li>
<li><code>upname</code> 查看系统启动时间和工作负载。-p526</li>
<li><code>netstat</code> ：跟踪网络，列出系统网络连接状态。参数：<code>-a</code> 将系统中所有连接显示出来。-p527</li>
<li><code>dmesg</code> ：分析内核产生的信息。-p528</li>
<li><code>vmstat [delay] [num]</code> ：检测系统资源变化。参数：<code>-a</code> 列出cpu和内存等信息；<code>delay</code> 延迟刷新时间；<code>num</code> 总计检测次数。-p528</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础(1)-Spring简介</title>
    <url>/2020/04/05/Spring%E5%9F%BA%E7%A1%80-1-Spring%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文档内容为B站“狂神说Java”课程的笔记，外加自己的个人理解。下面正式开始：</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html" target="_blank" rel="noopener">Spring官方文档-En</a></p>
<ul>
<li>Spring是一个开源免费的框架（容器）</li>
<li>Spring是一个轻量级的、非入侵式（不对原代码产生影响）</li>
<li>控制翻转（IOC），面向切面编程（AOP）</li>
<li>支持事务处理，对框架的支持</li>
</ul>
<a id="more"></a>

<p>总结：Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/Spring7%E4%B8%AA%E7%BB%84%E6%88%90.png" alt="Spring7个组成"></p>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <code>BeanFactory</code>，它是工厂模式的实现。<code>BeanFactory</code> 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/Spring%20Boot.png" alt="SpringBoot"  />

<ul>
<li>Spring Boot：一个快速开发的脚手架<ul>
<li>基于Spring Boot可以快速开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>Spring Cloud基于Spring Boot来实现的</li>
</ul>
</li>
<li>Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；</li>
<li>Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</li>
</ul>
<p>学习Spring Boot的前提是需要完全掌握Spring及Spring MVC</p>
<p>弊端：Spring本身发展了太久，违背了原来的理念，配置十分繁琐，但是Spring Boot很好的解决了这个问题。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot运行原理简介</title>
    <url>/2020/08/15/Spring-Boot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><p>一个最基本的Spring Boot项目一般是从<code>pom.xml</code>文件开始研究的，打开项目的<code>pom.xml</code>文件，一项项看着走：</p>
<p>1.父依赖<a id="more"></a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点进去后发现，还能找到下一个父依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；我们引入的依赖如果不在版本控制中，那么才需要手动写上版本号。</p>
<p>2.starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>starter就是spring boot的场景启动器，我们可以理解为一个可插拔式的插件，starter和普通jar包的区别在于，它能够实现自动配置，和Spring Boot无缝衔接，从而节省我们大量开发时间。</p>
<h2 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h2><p>我们可以很轻松找到主启动类，里面代码也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringBootApplication 来标注一个主程序类</span></span><br><span class="line"><span class="comment">//说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//以为是启动了一个方法，没想到启动了一个服务</span></span><br><span class="line">      SpringApplication.run(SpringbootApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到起作用的其实就是<code>@SpringBootApplication</code>这个注解，作用：标注在某个类上说明这个类是SpringBoot的主配置类 。这是一个复合注解，点进去可以发现其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看似包含了一堆注解，其实最重要的也就只有三个：</p>
<ul>
<li><code>@SpringBootConfiguration</code></li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code></li>
</ul>
<p>我们现在一个一个看：</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p><code>@SpringBootConfiguration</code>也是一个复合注解，可以继续往下点，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(</span><br><span class="line">        annotation = Configuration<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    )</span></span><br><span class="line"><span class="class">    <span class="title">boolean</span> <span class="title">proxyBeanMethods</span>() <span class="title">default</span> <span class="title">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有个熟悉的注解：<code>@Configuration</code>，其实<code>@SpringBootConfiguration</code>继承自<code>@Configuration</code>。二者功能也一致，标注当前类是配置类（配置类就是对应Spring的xml 配置文件）。</p>
<p>启动类标注了<code>@Configuration</code>之后，本身其实也是一个IoC容器的配置类，意味着将启动类中声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>先说结论，<code>@EnableAutoConfiguration</code>是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到Ioc容器。它也是一个复合注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最重要的是：<code>@Import({AutoConfigurationImportSelector.class})</code>，借助引入<code>AutoConfigurationImportSelector</code>这个类，<code>@EnableAutoConfiguration</code>可以帮助Springboot应用将所有符合条件的@configuration都加载到当前的SpringBoot创建并使用的Ioc容器。</p>
<p>AutoConfigurationImportSelector ：顾名思义，就是自动配置导入选择器，那么它会导入哪些组件的选择器呢？继续点开源码，注意到类中有如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从<code>loadFactoryNames()</code>方法往下一路追踪，可以发现<code>loadFactoryNames()</code>读取了ClassPath下面的 META-INF/spring.factories 文件，这就是spring自动配置的幕后英雄。</p>
<p>spring.factories是一个典型的java properties文件，配置格式为key-value形式，只不过key和value都是java类型的完整类名。摘抄一段如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/spring_factories.jpg" alt="spring_factories"></p>
<p>现在找一个EnableAutoConfiguration的配置类来看看，比如<code>org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/webMvcConfig.jpg" alt="webMvcConfig"></p>
<p>这是一个典型的JavaConfig配置类，因此，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>扫描当前包及其子包下被<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>注解标记的类并纳入到spring容器中进行管理。相当于以前的<code>&lt;context:component-scan&gt;</code>（以前使用在xml中使用的标签，用来扫描包配置的平行支持）。</p>
<p>我们可以通过basePackages等属性指定@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现从声明@ComponentScan所在类的package进行扫描，默认情况下是不指定的，所以SpringBoot的启动类最好放在root package下。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
