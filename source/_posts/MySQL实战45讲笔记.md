---
title: MySQL实战45讲笔记
date: 2020-08-16 11:37:42
categories:  MySQL
tags:
  - MySQL
---

MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。

本文是[MySQL实战45讲](https://time.geekbang.org/column/intro/139)的个人总结笔记，将讲义中自己觉得比较精华的部分记录下来，提供日后参考和复盘。<!--more-->

## 01讲基础架构：一条SQL查询语句是如何执行的

> MySQL底层基本架构：

![MySQL基本架构](https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/MySQL基本架构.png)

- Server层
  - 连接器：负责跟客户端建立连接、获取权限、维持和管理连接
  - 查询缓存：保存之前的查询结果，key-value格式，命中能直接返回
  - 分析器：词法分析+语法分析
  - 优化器：选择合适索引，决定join顺序等
  - 执行器：执行sql，类似for循环，直到不满足条件为止
- 存储引擎层
  - MyISAM
  - InnoDB

## 02讲日志系统：一条SQL更新语句是如何执行的

update语句首先会找到符合条件的行，这个步骤和select的执行流程一样。

WAL（Writer-Ahead Logging）技术：先写日志，再写磁盘。当有记录需更新，InnoDB引起先将记录写入redo log，并更新内存，然后在适当的时候再更新到磁盘做持久化。

> redo log（InnoDB引擎日志）：
>

- write pos：当前正在写入的位置
- checkpoint：当前正在擦除（持久化）的位置，从write pos到checkpoint之间的位置，即为空白区，可以写入
- crash-safe：数据库即使重启，因为有了redo log，之前提交的记录都不会丢失

> binlog（Server层日志）：
>

- 只能用于归档，没有crash-safe能力
- 和redo log的区别
  - 所处的位置不同
  - redo log是物理日志，记录的是具体action（在某个数据页上进行了什么修改），binlog是逻辑日志，记录的是意图（比如给id=2的行c字段加1）
  - redo log是循环写，空间是固定的，而binlog是往后追加写的，这一页放不下就切换下一页

> 两阶段提交：
>

- 先写入redo log，状态处于prepare
- 写入binlog到磁盘
- 提交事务，redo log状态改为commit

其核心目的是为了保证两个日志文件的逻辑一致性。当遇到系统宕机时，总共2*2=4种情况，分析其逻辑：

- binlog有记录，redo log状态commit：正常完成的事务，无需恢复；
- binlog有记录，redo log状态prepare：说明是在binlog写完，而redo log没有提交的时候crash，恢复操作：提交事务
- binlog无记录，redo log状态prepare：说明是在binlog写入之前crash，恢复操作：回滚事务
- binlog无记录，redo log无记录：说明在redo log之前就crash，恢复操作：回滚事务

把binlog夹在redo log之间做提交，这样可以根据二者状态，准确进行crash后的恢复

## 03讲事务隔离：为什么你改了我还看不见

> 事务：
>

- 保证一组数据库操作，要么全部成功，要么全部失败
- 事务是在引擎层实现的，MyISAM就不支持事务，而InnoDB正好支持

> 数据库事务隔离级别：

- 读未提交：事务中的修改，即使没有提交，其他事务也可以看得到
- 读已提交：事务中的修改只有提交以后才能被其它事务看到
- 可重复读：在事务中看到的每行的记录的结果是一致的
- 串行化：所有的事务都是串行执行的，一个事务执行完了才能执行其它的事务，可以解决所有的并发问题，它是靠大量加锁实现的

> 常见并发问题：

- 脏读：一个事务读取到了另一个事务尚未提交的数据（只有读未提交才可能引发）
- 不可重复读：事务A修改了数据，导致事务B多次读取的记录不一致（读未提交和读已提交可能引发）
- 幻读：事务A插入或者删除记录，导致事务B多次读取的记录数量不一致（只有加锁才能避免，因此除了串行化，其他皆有可能引发）

## 04讲深入浅出索引（上）

索引：就像书的目录一样，为了提高数据查询的效率而出现的数据结构。

> 三种常见的索引模型：

- 哈希表

  - 哈希表是一种以键-值（key-value）存储数据的结构，输入待查找的key，就可以找到其对应的value
  - 实现思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
  - 会出现多个key对应同一个value的情况，解决方法：使用链表，当key1和key2都命中value1的时候，通过链表顺序遍历，找到key1对应的确定元素
  - 优点：**哈希表这种结构适用于只有等值查询的场景**，速度很快
  - 缺点：数据存储不是有序的，所以哈希索引做区间查询的速度很慢

  ![哈希表示意图](https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/哈希表示意图.png)

- 有序数组

  - 有序数组根据主键ID进行顺序存储
  - 优点：等值查询（利用二分法）和范围查询性能都很优秀
  - 缺点：更新数据很麻烦，需要移动的数据量太大，**只适用于作为静态存储引擎**

  ![有序数组示意图](https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/有序数组示意图.png)

- 二叉搜索树

  - 二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子。精确搜索的时间复杂度是O(log(N))。
  - 主要问题：二叉搜索树分的太细，导致数据块较多，从而读取磁盘的次数变多，对于数据量大的表查询，实际查询时间不一定快的起来。
  - 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块，要使用“N叉”树，这里“N叉”树中的“N”取决于数据块的大小。（InnoDB的一个整数字段索引为例，这个N差不多是1200）

  ![二叉搜索树示意图](https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/二叉搜索树示意图.png)

> 为了更好理解InnoDB引擎，这里必须插播关于B+树的基本介绍，后面会专门写文理解：

![B+树结构](https://cdn.jsdelivr.net/gh/sangthian/CloudPic@master/uPic/B+树结构.jpg)

B+树的特征：

- 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

- 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

B+树的优势：

- 单一节点存储更多的元素，使得查询的IO次数更少。

- 所有查询都要查找到叶子节点，查询性能稳定。

- 所有叶子节点形成有序链表，便于范围查询。

> InnoDB的索引模型

- 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表
- 每一个索引在InnoDB里面对应一棵B+树
- 根据叶子节点内容，分为主键索引和非主键索引：
  - 主键索引：叶子节点存储整行数据
  - 非主键索引：叶子结点存储主键的值（查其他字段数据则需要再到主键索引树找一遍，称之为回表）
- 索引的维护：
  - 普通索引的增删涉及到页的合并和分裂，原因是ID的不连续（在树的中间进行增删操作）
  - 如果使用自增主键，那么每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂
- 主键的选取：业务允许尽量使用自增主键，好处在于好维护和占用空间少（非主键索引能减少叶子节点的存储空间）