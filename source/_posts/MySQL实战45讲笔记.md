---
title: MySQL实战45讲笔记
date: 2020-08-16 11:37:42
categories:  MySQL
tags:
  - MySQL
---

本文是[MySQL实战45讲](https://time.geekbang.org/column/intro/139)的个人总结笔记，将讲义中自己觉得比较精华的部分记录下来，提供日后参考和复盘。

## 01讲基础架构：一条SQL查询语句是如何执行的

MySQL底层基本架构

- Server层
  - 连接器：负责跟客户端建立连接、获取权限、维持和管理连接
  - 查询缓存：保存之前的查询结果，key-value格式，命中能直接返回
  - 分析器：词法分析+语法分析
  - 优化器：选择合适索引，决定join顺序等
  - 执行器：执行sql，类似for循环，直到不满足条件为止
- 存储引擎层
  - MyISAM
  - InnoDB

## 02讲日志系统：一条SQL更新语句是如何执行的

update语句首先会找到符合条件的行，这个步骤和select的执行流程一样。

WAL（Writer-Ahead Logging）技术：先写日志，再写磁盘。当有记录需更新，InnoDB引起先将记录写入redo log，并更新内存，然后在适当的时候再更新到磁盘做持久化。

redo log（InnoDB引擎日志）：

- write pos：当前正在写入的位置
- checkpoint：当前正在擦除（持久化）的位置，从write pos到checkpoint之间的位置，即为空白区，可以写入
- crash-safe：数据库即使重启，因为有了redo log，之前提交的记录都不会丢失

binlog（Server层日志）：

- 只能用于归档，没有crash-safe能力
- 和redo log的区别
  - 所处的位置不同
  - redo log是物理日志，记录的是具体action（在某个数据页上进行了什么修改），binlog是逻辑日志，记录的是意图（比如给id=2的行c字段加1）
  - redo log是循环写，空间是固定的，而binlog是往后追加写的，这一页放不下就切换下一页

两阶段提交：

- 先写入redo log，状态处于prepare
- 写入binlog到磁盘
- 提交事务，redo log状态改为commit

其核心目的是为了保证两个日志文件的逻辑一致性。当遇到系统宕机时，总共2*2=4种情况，分析其逻辑：

- binlog有记录，redo log状态commit：正常完成的事务，无需恢复；
- binlog有记录，redo log状态prepare：说明是在binlog写完，而redo log没有提交的时候crash，恢复操作：提交事务
- binlog无记录，redo log状态prepare：说明是在binlog写入之前crash，恢复操作：回滚事务
- binlog无记录，redo log无记录：说明在redo log之前就crash，恢复操作：回滚事务

把binlog夹在redo log之间做提交，这样可以根据二者状态，准确进行crash后的恢复

## 03讲事务隔离：为什么你改了我还看不见

事务：

- 保证一组数据库操作，要么全部成功，要么全部失败
- 事务是在引擎层实现的，MyISAM就不支持事务，而InnoDB正好支持

数据库事务隔离级别：

- 读未提交：事务中的修改，即使没有提交，其他事务也可以看得到
- 读已提交：事务中的修改只有提交以后才能被其它事务看到
- 可重复读：在事务中看到的每行的记录的结果是一致的
- 串行化：所有的事务都是串行执行的，一个事务执行完了才能执行其它的事务，可以解决所有的并发问题，它是靠大量加锁实现的

常见并发问题：

- 脏读：一个事务读取到了另一个事务尚未提交的数据（只有读未提交才可能引发）
- 不可重复读：事务A修改了数据，导致事务B多次读取的记录不一致（读未提交和读已提交可能引发）
- 幻读：事务A插入或者删除记录，导致事务B多次读取的记录数量不一致（只有加锁才能避免，因此除了串行化，其他皆有可能引发）